<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>Has Covid taught humans a valuable climate lesson?</title>
    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/ada-2022-project-wetried/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/ada-2022-project-wetried/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/ada-2022-project-wetried/assets/css/syntax.css" />
    <!--
    <link rel="stylesheet" type="text/css" href="assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="assets/css/syntax.css" />
    -->

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
    <link rel="canonical" href="https://epfl-ada.github.io/ada-2022-project-wetried/" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/ada-2022-project-wetried/page2/" />

    <meta property="og:site_name" content="Has Covid taught humans a valuable climate lesson?" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Has Covid taught humans a valuable climate lesson?" />
    <meta property="og:description" content="subtitle" />
    <meta property="og:url" content="https://epfl-ada.github.io/ada-2022-project-wetried/" />
    <meta property="og:image" content="/ada-2022-project-wetried/assets/images/cover1.png" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Has Covid taught humans a valuable climate lesson?",
    "name": "Has Covid taught humans a valuable climate lesson?",
    "url": "http://localhost:4000/ada-2022-project-wetried//",
    "image": "/ada-2022-project-wetried/assets/images/cover1.png",
}
    </script>


    <!-- CHART -->
    <style>
        #chartdiv {
            height: 800px;
            background-color:#212327;
        }
    </style>

    <!-- Resources -->
    <script src="https://cdn.amcharts.com/lib/4/core.js"></script>
    <script src="https://cdn.amcharts.com/lib/4/charts.js"></script>
    <script src="https://cdn.amcharts.com/lib/4/maps.js"></script>
    <script src="https://cdn.amcharts.com/lib/4/geodata/worldLow.js"></script>
    <script src="https://covid.amcharts.com/data/js/world_timeline.js"></script>
    <script src="https://covid.amcharts.com/data/js/total_timeline.js"></script>
    <script src="https://cdn.amcharts.com/lib/4/themes/animated.js"></script>

    <meta name="generator" content="Jekyll 3.0.0" />

</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home  nav-current" role="presentation"><a href="/ada-2022-project-wetried/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/ada-2022-project-wetried/appendix.html">Appendix</a></li>
    </ul>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <header class="main-header "
                style="background-image: url(/ada-2022-project-wetried/assets/images/cover1.png) ">
            <nav class="main-nav overlay clearfix">
                <a class="blog-logo" href="/ada-2022-project-wetried/"><img src="/ada-2022-project-wetried/assets/images/ghost.png" alt="Blog Logo" /></a>
                
                    <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
                
            </nav>
            <div class="vertical">
                <div class="main-header-content inner">
                    <h1 class="page-title">Has Covid taught humans a valuable climate lesson?</h1>
                </div>
            </div>
            <a class="scroll-down icon-arrow-left" href="#content" data-offset="-45"><span class="hidden">Scroll Down</span></a>
        </header>

        <!-- The main content area on the homepage -->
        <main id="content" class="content" role="main">
            <article class="post">
                <h1>Introduction</h1>
                <hr/>
                <p>
                    When the first Covid-19 wave hit the world, countries from all around the world had to go into lockdown for some weeks/months.
                    In order to keep themselves sane, they had to find different forms of entertainment; one of them is Wikipedia, 
                    as we can see an increase in its usage around that time. In the same period, headlines were going around about how air pollution
                    was reduced (in China for example) as a result of transportation/mobility changes.
                </p>

                <p>
                    We thus wondered: did that have an impact on people, as in, did that make them more environmentally conscious? 
                    In an attempt to answer this question, we will use <a href="https://arxiv.org/pdf/2005.08505.pdf">the Coronawiki dataset</a> 
                    which contains Wikipedia views data 
                    from 2018 to July 2020 for 14 languages, as well as mobility changes data that happened during the 2020 wave for the 
                    countries corresponding to these languages. Most of this data are time series. In the note that this is only an approximation, 
                    and for that reason we will go beyond by including global pollution data, and link it with the Wikipedia data.
                </p>

                <h2 id="heading2">World Map</h2>
                <p>In this map, you can see the air pollution, the total number of Wikipedia views and the number of views for articles in the environment topic per day and studied country.</p> 
                <p>You can click on a country to see its specific graph. Clicking again on the country return to the world view.</p>
                <p><var>Try to compare the evolution of the Wikipedia views with the evolution of the views for articles in the environment topic. You might find some surprising results.</var></p>
            </article>
        </main>

        <div id="chartdiv" style="margin: 1%;"></div>

        <main id="content" class="content" role="main">
            <article class="post">
                <h1>The evolution of awareness over time </h1>

                <h2>CoronaWiki</h2>

                <p>
                    To begin, we will consider the following: an increase in the visits to a given topic corresponds to an increase in awareness 
                    for that particular topic. Here, we are talking about increases that are more or less unique to that subject itself, i.e if 
                    all topics increase in view counts at the same time, we can't say much about the awareness related to a topic in particular.
                </p>

                <p>
                    Let us note that all Wikipedia data in Coronawiki is encapsulated in 64 topics, in which environment articles are concentrated 
                    in only one of them (STEM.Earth and environment). As such, the orders of magnitude between the views from only that topic and the rest 
                    of Wikipedia are very different; whenever we need them to be compared, we will scale them to be between 0 and 1, where 1 represents the
                    peak of each series.
                </p>

                <p>
                    As a first general result, we can have a quick look to check if all Wikipedia views evolve differently from environmental views during 
                    the first 2020 Covid wave. We do that by plotting the trends of both time series using a period of 14 days.
                </p>
                <div>
                    <iframe width="600" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/12.embed?autosize=true&link=false"></iframe>
                </div>

                <p>
                    At a quick first glance, one can see that until the first half of March, the two don’t evolve in the same way: it appears that the 
                    environment views reach their maximum in the earliest part of 2020, after which it decreases until the middle of March. Following that, 
                    it appears to have a similar trend to the general trend of global Wikipedia views. However, this is the data in its most coarse grained 
                    and general form; we have to do a lot more analysis by considering each language separately (English does dominate the data after all), 
                    and by using the 2019 data as a way to compare with normality. Note that we map most of these languages to the countries/cities where 
                    they are the most used (not feasible with English)
                </p>

                <h3>Difference in difference regression</h3>

                <p>
                    In order to be more precise, and to better determine the effects of lockdowns and mobility changes on environmental visits, we do what 
                    is called a Difference-in-difference regression: basically, it is a type of regression that uses the concept of control and treatment 
                    groups, simulating an experimental design with observational data. Here, the treatment would correspond to certain mobility changes in 
                    2020, and we take the same dates in 2019 as control. For each language and date (mobility restriction/return to normal), we take a window 
                    of 5 weeks for the data.
                </p>

                <p>
                    The goal is to separate the effects of the mobility changes from seasonal changes, i.e. changes that happen every year around the same 
                    period of time. 
                </p>

                <p>
                    As the outcome, we use the logarithm of the environmental page views; the range views vary greatly depending on the language, so the 
                    logarithm mitigates that; plus, it makes the model multiplicative, and facilitates the comparison between languages. As variables, 
                    we use is_2020 (self-explanatory), language (clear what it is as well), and period (whether we are in the chosen treatment group 
                    for that comparison or not).  
                    The R formula for these regressions is:
                </p>

                <p>
                    <img src="/ada-2022-project-wetried/assets/images/CodeCogsEqn.png" alt="Image (input)" style="display: block;
                        margin-left: auto;margin-right: auto;">
                </p>

                <p>
                    Three comparisons are made for each language:
                </p>
                
                <ul>
                    <li>
                        The difference in environment visits before vs after the mobility restriction, as to see the immediate effects
                    </li>
                    <li>
                        The difference before the mobility restriction vs after the return to normalcy, to see if similar mobility necessarily mean similar visits
                    </li>
                    <li>
                        The difference after the mobility restriction vs after the return to normalcy, to see the evolution as restrictions were lifted little by little.
                    </li>
                </ul>

                <p>
                    The results are in the following three figures; note that the values are actually exponents, and so they correspond to a multiplicative effect 
                    when applying the exponential function.
                </p>

                <div>
                    <iframe width="100%" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/3.embed?autosize=true&link=false"></iframe>
                </div>    
                
                <div>
                    <iframe width="100%" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/8.embed?autosize=true&link=false"></iframe>
                </div>

                <div>
                    <iframe width="100%" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/10.embed?autosize=true&link=false"></iframe>
                </div>

                <p>
                    The changes are not unfortunately all statistically significant; the languages with red confidence intervals are those for 
                    which we can’t derive conclusions. Let us go figure by figure now:
                </p>
               
                <ul>
                    <li>
                        For the pre-vs-post mobility changes, half of the changes are not significant. We see a general increase that can range from 116% for 
                        Japanese, to 224% for Serbian (for this language though, it is sure to be because of political confounders other than Covid). 
                    </li>
                    <li>
                        For the pre-mobility vs post-normalcy comparison, the changes are now statistically significant for a majority of the languages; 
                        and interestingly, despite the same mobility in both periods, there is a drop in views for most of the languages after the return 
                        to normal.
                    </li>
                    <li>
                        Lastly, the post-mobility vs post-normalcy one corroborates the two other regressions: on average, post_mobility > pre_mobility, 
                        and pre_mobility > post_normalcy => post_mobility > post_normalcy.
                    </li>
                </ul>

                <p>
                    At this point, one might tell themselves that this in itself is enough as an analysis; people may have cared more during the first wave,
                    but they stopped caring after restrictions were lifted. But that isn’t satisfying as a result in itself; we need to look at the question 
                    from multiple angles. As such, let us push the analysis further. Let us get more precise, by looking at the level of the languages; 
                    remember that in the first figure we just took all languages together, now we will separate them: we want to see if the 
                    increases/decreases in environment views are proper to the topic itself, or whether they just follow the general Wikipedia trend.
                </p>

                <p>
                    If we do find different behaviors, we can then study them closely and maybe find periods where for example the global views have a
                    downward trend and the environment views have an increasing trend, and this might mean that during that time we have an attention shift towards the environment.   
                </p>

                <h3>Dynamic Time Warping</h3>

                <p>
                    Dynamic time warping (DTW) is a way to compare two usually temporal sequences that do not sync up perfectly. It is a method to calculate the optimal
                    matching between two sequences. It’s commonly used to measure the distance between two time-series. We will, for each language, apply this algorithm 
                    between the environment-related views and all views for that language. Examples of results are below, you can find the graph for every studied country 
                    in the <a href="/ada-2022-project-wetried/appendix.html">appendix</a>.
                </p>

                <div style="display: flex; width: 100%; margin-left: auto; margin-right: auto;">
                    <img src="/ada-2022-project-wetried/assets/images/dtw_en.png" alt="Image (input)" style="display: block; width: 50%; height: 50%;">
                    <img src="/ada-2022-project-wetried/assets/images/dtw_ko.png" alt="Image (input)" style="display: block; width: 50%; height: 50%;">
                </div>

                <p>
                    For Italian, Norwegian, English and Dutch, the time series are really close to each others, and because the shortest path is 
                    really close to the matrix diagonal, we can say that the time series are behaving similarly (up to the scales of the values and time dilation). 
                    This may indicate that the evolution in environment views and Wikipedia views may behave very similarly.
                </p>

                <p>
                    For some of the other languages (Korean or Swedish for example), the distances on one hand are higher than average, and the plots are very far 
                    from being lines. This means that DTW didn't find a mapping that is even close to one-to-one for most of the points, i.e., the environment views 
                    and the total Wikipedia evolution for these languages are different.
                </p>

                <h3>Time lagged cross correlation</h3>

                <p>
                    Time lagged cross correlation is meant to add to the above analysis; it studies the correlation between the two time series by shifting one 
                    of them positively or negatively in time, as to see if we can obtain one from the other that way. The closer the peak synchrony is to 0, the 
                    more synchronous the time series are; the contrary is also true, and this is what we tried to look for. Two examples of outputs are below:
                </p>

                <p><img src="/ada-2022-project-wetried/assets/images/pearson_en.png" alt="Image (input)" 
                        style = "display: block;
                                margin-left: auto;
                                margin-right: auto;
                                width: 100%;
                                "></p>

                <p><img src="/ada-2022-project-wetried/assets/images/pearson_de.png" alt="Image (input)" 
                    style = "display: block;
                            margin-left: auto;
                            margin-right: auto;
                            width: 100%;
                            "></p>

                <p>
                    Again, the results are unanimous for a lot of languages: apparently, people’s environment visits are often simply synchronized with 
                    their visits to other Wikipedia topics (example of the first figure).
                </p>

                <p>
                    Some outliers exist : Such a case here is German, for which an offset of 140 has a Pearson coefficient of 0.75, meaning that the wikipedia 
                    views at time  almost “overlap” with the environment views at time .  Meanwhile, for most of the other languages (Serbian, Catalan, French, 
                    Italian, Norwegian, ….), the offset that maximizes the cross correlation is 0. As such, we cannot really conclude much as the wikipedia views 
                    and environment views behave very similarly, so any increase in the environment views appears to be due to just an increase in Wikipedia views 
                    in general. 
                </p>

                <p>
                    Ok so… no matter how you look at it, it appears that for almost all languages, people’s visits to environmental topics seems to be caused by 
                    the usage of Wikipedia as a whole. However, this wouldn’t mean that people didn’t care about the environment; maybe it was the one of most 
                    visited topics after all?
                </p>

                <p>
                    To that end, we decided to study the ranking of the views of the environment compared to the rest, to see whether or not it is one of the 
                    most important topics. A ranking of 1 means that it is the most viewed subject, while a ranking of 64 means the opposite.
                </p>

                <div>
                    <iframe width="100%" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/28.embed?autosize=true&link=false"></iframe>
                </div>

                <p>
                    Here we can see that the ranking of the environment oscillates around 47 which is pretty low considering there are 64 topics, moreover 
                    from January 2020 to July 2020 it drops to 51 showing that people's attention shifted away from the environment during covid.
                </p>

                <p>
                    So far, the picture isn’t pretty: the difference-in-difference gives us a good first result, but digging deeper shows us that not only 
                    people’s visit to environmental topics is most likely caused by a general increase in Wikipedia’s usage, but also that the topic isn’t 
                    even at the top priority given its low rank.
                </p>

                <h2>Environment topic views extension</h2>
                
                <p>
                    After the results obtained using CoronaWiki, we started to think that the analysis of the environment could be improved by using a larger 
                    timeframe. Indeed, until now, we were only focusing on three years 2018 to 2020. By increasing this interval, we could get a better sense of the 
                    evolution of the environment topic views count.
                </p>

                <p>
                    Thus, we decided to aggregate all the views of every Wikipedia pages in the topic environment starting from the earliest date possible 
                    (01/07/2015) to the end of 2022 (20/11/2022). The following graph shows the distribution of the views for the topic for each year.
                </p>

                <div>
                    <iframe width="100%" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/30.embed?autosize=true&link=false"></iframe>
                </div>

                <p>
                    If CoronaWiki data showed a grim view, the global view is even more troubling. Not only the environment topic is not the user priority, 
                    but it is clear that, after the Covid crisis, interest in it fell dramatically. In 2022, even the outliers are not bigger than the third 
                    fence of 2021.
                </p>

                <p>
                    However, just like people say “actions speak louder than words”, we say : 
                </p>

                <blockquote>
                    <p>
                        Views speak better when combined with actions
                    </p>
                </blockquote>

                <p>
                    To analyze 
                    better, we needed data about the pollution itself, but also more up-to-date Wikipedia data (Coronawiki, again, stops at the end of 
                    July 2020).
                </p>
                
                <h1>Air pollution around the world</h1>

                <p>
                    Let’s have a look at the other dataset which we imported : we study the air pollution from the World Air Quality Index (WAQI), 
                    as this will prove to be a good marker of the results of policies about pollution. There is no access to pollution by country per se, 
                    but we do have the data per city. Therefore, we will assume that the pollution of a country can be proxied by the pollution of its 
                    capital city. This is a good representative in most cases, as the capital city usually concentrates a decent portion of the activities 
                    of the country. This has limitations too : for example, we picked Washington D.C as the representative to the U.S., but it clearly isn’t 
                    the place where most of the activities of the country happen. It clearly brings some extra variance in the computations, but we think it 
                    is the best way to deal with the situation. Keeping that in mind, let’s have a look at the air pollution per year in the considered cities.
                </p>

                <div>
                    <iframe width="100%" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/14.embed?autosize=true&link=false"></iframe>
                </div>

                <p>
                    This gives a first taste in the distribution of air pollution with respect to time, it decreases globally.
                    We can then compare some pairs of years to check whether air pollution went up or down.
                </p>

                <div>
                    <iframe width="100%" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/16.embed?autosize=true&link=false"></iframe>
                </div>

                <p>
                    Here, we learn that for almost every capital city, the air was significantly cleaner during Covid times than before. There is an exception 
                    for Ankara in Turkey, which is the only capital city that polluted more during Covid than before. Tokyo is not significant, but also shows 
                    a drop in average pollution during Covid.
                </p>

                <div>
                    <iframe width="100%" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/18.embed?autosize=true&link=false"></iframe>
                </div>
                
                <p>
                    Here, the results are much less significant, as the test could not manage to find a lot of cities where 2020 and 2021 were somehow different. 
                    We only have Belgrade (Serbia) and Helsinki (Finland) that showed a significant boost in pollution between 2020 and 2021. In this sense, 
                    the years 2020 and 2021 are very much alike.
                </p>

                <div>
                    <iframe width="100%" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/20.embed?autosize=true&link=false"></iframe>
                </div>

                <p>
                    This is perhaps the surprise of this part. We find that between 2019 and 2021, the only significant changes show that the cities are doing 
                    better in 2021 in terms of air pollution, the only exceptions being Barcelona (Spain) and Helsinki (Finland).
                </p>

                <p>
                    Okay, let’s sum up our findings : first, we can definitely argue that the air pollution typically goes down with time. There is a particular 
                    time at which this drop occurs : 2020 shows a massive drop worldwide, which we can reasonably attribute to Covid. However, there was no 
                    massive recovery of air pollution when the Covid restrictions stopped. Assuming this remains true, there is hope about the air pollution 
                    worldwide : the air can remain significantly cleaner even after the post-Covid recovery.
                </p>

                <p>
                    Now that we have analyzed pollution, there is a natural question to ask : how does pollution evolve with the awareness of the population ? 
                    This is what we will study next.
                </p>

                <h1>How is the awareness linked to air pollution?</h1>

                <p>
                    The goal is to establish whether there is a link between awareness (i.e. Wikipedia views) and actual ground measurements about pollution. 
                    We will perform two experiments for each country :
                </p>

                <ul>
                    <li>
                        <strong>Intervention analysis</strong> : we find the peak of wikipedia views for a given wikipedia subject or page in 2020 (the peak of 
                        awareness, which we call the intervention) and check whether this peak translates to a significant change in empirical pollution.
                    </li>

                    <li>
                        <strong>Causality testing</strong> : we test whether a given timeseries (wikipedia views) can be used to linearly predict the future of another 
                        timeseries (say, pollution). This gives us a hint about the temporal relationship between two observations.
                    </li>
                </ul>

                <p>Here's a few interesting results by themselves :</p>

                <ul>
                    <li>
                        First of all, most countries have less air pollution after the peak of their environment Wikipedia page of 2020. That alone is however 
                        not enough to explain the whole story : both periods of 365 days have strong similarities.
                    </li>
                    <li>
                        Analyzing in that direction, there seems to be a group of countries that stand out : Japan, Italy, Turkey, Norway, the U.S., Serbia, 
                        the Netherlands, Norway, Korea and Finland all have a air pollution that is U-shaped, meaning they are highly seasonal and binary 
                        (summer = no pollution, winter = strong pollution). France and Germany also show a similar behavior, but with a seemingly higher 
                        variance. This is hardly the case for the last two : Denmark and Sweden are less well-behaved in terms of pollution seasonality. 
                        Looking at it globally, we can conclude that there is a strong seasonality of pollution worldwide.
                    </li>
                </ul>

                <div>
                    <iframe width="100%" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/22.embed?autosize=true&link=false"></iframe>
                </div>

                <p>
                    These results are in line with the rest of the air pollution analysis earlier : countries significantly reduced their air pollution 
                    between these two periods. The only exception is Turkey. This Wikipedia page gives a bit of an explanation : NOx car pollution and 
                    lack of pollution regulation are a large part of the problem. We however could not explain why the pollution goes up instead of 
                    stagnating, for example. Serbia also shows a slight increase in air pollution, but this is not a significant change from before the peak.
                </p>

                <h2>Daily views vs actual pollution</h2>

                <p>
                    We can also ask a related but different question : is it true that the value of wikipedia views of the environment topic can 
                    linearly predict air pollution ?
                </p>

                <p>
                    We use the Granger test, which analyzes whether the past of a given time series is useful in linearly predicting another. 
                    The point is then to check whether the past of the wikipedia views of a given country can predict the future of the air 
                    pollution in the capital of said country. 
                </p>

                <p>
                    We find that for most countries, past wikipedia views make for a good linear predictor of the future of air pollution. 
                    This even holds for Turkey where the air pollution got worse during Covid.
                </p>

                <p>
                    An interesting case is that of Japan and South Korea which have very insignificant p-values (>.2), suggesting that 
                    day-to-day linear prediction is not very convincing for these two countries. We note that these are the only
                    Eastern-Asian countries in the dataset. An interesting extension to this project could be to check whether this 
                    extends further to other countries in the area.
                </p>

                <p>
                    For most other countries, the process was much more continuous and the linear prediction works out fine. 
                    The model is confident that the past of the wikipedia views is a useful tool to predict the air pollution of 
                    the next day in the capital.
                </p>

                <p>
                    What can we learn from this ? This result is weaker than proving that decreases in air pollution are caused 
                    by a corresponding hike in awareness. However, we learned that the past of awareness is a good linear predictor 
                    by itself for the present and close future of air pollution.
                </p>

                <h1>What if ? And what happens next ?</h1>

                <p>
                    In this final part, we want to create a hypothetical scenario of 2022 using statistical forecasting without the
                    data from that year. The idea is to show whether the direction air pollution is taking is predictable, and where 
                    it is headed.
                </p>

                <p>
                    For statistical forecasting, we will use the SARIMA model which enables the prediction of the future of a 
                    time series by using the previous data points and accounting for seasonality.
                </p>

                <p>
                    We will analyze the data in the following way : we will predict whether the air pollution in the period of 
                    2022 can be meaningfully predicted from the previous years. This enables us to ask the following question : 
                    "does the air pollution in 2022 significantly change from the trends of 2019-2021, and if so, what is the 
                    direction of the change?". This will give us insights into what the different countries have "learned". 
                    For example, a year 2022 that is unpredictably low in terms of air pollution means that the country has 
                    (for now) learned that it could survive without as much pollution.
                </p>

                <p>
                    There could be other explanations (the country never economically recovered from Covid, ...) but there 
                    is little we can do to account for this in time. Besides, speaking only in terms of air pollution, the 
                    conclusion would be the same : the country is for the foreseeable future on its way to having better air.
                </p>

                <p>
                    The results of the prediction go as follows : 
                </p>

                <div>
                    <iframe width="100%" height="450" frameborder="0" scrolling="no" src="//plotly.com/~MrZaiko/24.embed?autosize=true&link=false"></iframe>
                </div>

                <p>
                    Here, we have fairly binary results :
                </p>

                <ul>
                    <li>
                        Either the country has actual pollution that is lower than the prediction (Japan, Turkey, Norway, the U.S., 
                        Germany, France, Korea, Finland). The country that has the largest error is in this category: it is Turkey, 
                        which has a massive drop in air pollution in 2022, while its trend was increasing before that year.
                    </li>

                    <li>
                        Or it has actual pollution that is higher than the prediction (Italy, Serbia, Sweden, the Netherlands, 
                        Catalonia). In this case, the largest difference between the actual pollution is Sweden, which is 
                        explained by noticing that the values for Sweden are usually really low, and that there is a small, 
                        unexplained peak in the air pollution in 2022. This is seen in the Sarima trends graph of the country. 
                        Most countries in this category behave this way.
                    </li>
                </ul>

                <p>We also note that Denmark is the only country with a full month of data missing, so it is not included in this study.</p>

                <p>
                    We can conclude in the following way : For most countries, it holds that either the model predicts a higher pollution 
                    than reality for 2022 or the country's emissions were already fairly low. This suggests that, when looking only at 
                    air pollution, it seems that humans were indeed taught a lesson by Covid in terms of climate change.
                </p>

                <h1>Conclusion</h1>

                <p>
                    If one looked only at the environment Wikipedia views, the image would be quite dark: people didn’t seem to 
                    necessarily care more about that topic during the wave, as any increase, is strongly correlated to the overall 
                    page views.
                </p>

                <p>
                    If the topic was one of the most visited, that would be okay, but that’s not even the case, as a matter of fact, 
                    it’s always at least in the 20 least visited topics. Not only that, but extending the Coronawiki data shows that 
                    people visit the environment pages even less in 2021 and 2022. 
                </p>

                <p>
                    However, the air pollution dataset enables us to argue that pollution indeed decreased overall during and after 
                    the 2020 Covid wave. This is further supported by the SARIMA modeling, which typically predicts more pollution 
                    for 2022 than actually happened.
                </p>

                <p>
                    All in all, we seem to be heading into a <kbd>bad ending</kbd>. While it is true that the pollution is getting better over 
                    time for now, the fact that awareness about the pollution decreases suggests that the decrease in pollution is 
                    only temporary and not a global effort to tackle climate change. 
                </p>

                <p>
                    That leaves the question of how to improve things. One may observe that awareness on Wikipedia has decreased
                    while media attention is ever-growing about climate change issues. Then, we can only hope that this newly-formed 
                    attention is beneficial to public knowledge about the issue and that it will lead to actual durable improvements 
                    to the current situation.
                </p>

            </article>
        </main>


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/ada-2022-project-wetried/">Has Covid taught humans a valuable climate lesson?</a> &copy; 2022</section>
          <section class="poweredby">Proudly created by the weTried team. Images generated using <a href="https://www.midjourney.com/home/">MidJourney</a></section>
        </footer>
    </div>

    

    
    <!-- Chart code -->
    <script>
    am4core.ready(function() {
    
    // Themes begin
    am4core.useTheme(am4themes_animated);
    // Themes end
    fetch('/ada-2022-project-wetried/assets/data/map_graph_data.json')
    .then(response => {
        return response.json();
    }).then((graph_data) => {
        fetch('/ada-2022-project-wetried/assets/data/line_graph_data.json')
        .then(response => {
            return response.json();
        }).then((line_data) => {
            am4core.ready(function() {
            
            var numberFormatter = new am4core.NumberFormatter();
            
            var backgroundColor = am4core.color("#1e2128");
            var activeColor = am4core.color("#ff8726");
            var airpolColor = am4core.color("#d21a1a");
            var globalviewsColor = am4core.color("#45d21a");
            var envviewsColor = am4core.color("#1c5fe5");
            
            // for an easier access by key
            var colors = { active: activeColor, airpol: airpolColor, globalviews: globalviewsColor, envviews: envviewsColor };
            
            var countryColor = am4core.color("#3b3b3b");
            var countryStrokeColor = am4core.color("#000000");
            var buttonStrokeColor = am4core.color("#ffffff");
            var countryHoverColor = am4core.color("#1b1b1b");
            var activeCountryColor = am4core.color("#0f0f0f");
            
            var currentIndex;
            var currentCountry = "World";
            
            // last date of the data
            var lastDate = new Date(line_data[line_data.length - 1].date);
            var currentDate = lastDate;
            
            var currentPolygon;
            
            var countryDataTimeout;
            
            var currentType;
            
            var currentTypeName;
            
            var sliderAnimation;
            
            var perCapita = false;
            
            //////////////////////////////////////////////////////////////////////////////
            // PREPARE DATA
            //////////////////////////////////////////////////////////////////////////////
            
            // make a map of country indexes for later use
            var countryIndexMap = {};
            
            var list = graph_data[graph_data.length - 1].list;
            for (var i = 0; i < list.length; i++) {
                var country = list[i]
                countryIndexMap[country.id] = i;
            }
    
            // function that returns current slide
            // if index is not set, get last slide
            function getSlideData(index) {
                if (index == undefined || isNaN(index)) {
                index = graph_data.length - 1;
                }
            
                var data = graph_data[index];
            
                // augment with names
                //for (var i = 0; i < data.list.length; i++) {
                //data.list[i].name = idToName(data.list[i].id);
                //}
            
                return data;
            }
            
            // get slide data
            var slideData = getSlideData();
            
            // as we will be modifying raw data, make a copy
            var mapData = JSON.parse(JSON.stringify(slideData.list));
            
            // remove items with 0 values for better performance
            for(var i = mapData.length - 1; i >= 0; i--){
                if(mapData[i].airpol == 0){
                mapData.splice(i, 1);
                }
            }
            
            
            var max = { airpol: 0, globalviews: 0, envviews: 0 };
            var maxPC = { airpol: 0, globalviews: 0, envviews: 0};
            
            // the last day will have most
            for (var i = 0; i < mapData.length; i++) {
                var di = mapData[i];
                
                // max
                if (di.airpol > max.airpol) {
                    max.airpol = di.airpol;
                }
                if (di.globalviews > max.globalviews) {
                    max.globalviews = di.globalviews;
                }
                if (di.envviews > max.envviews) {
                    max.envviews = di.envviews
                }
            }

            var totalMax = { airpol: 0, globalviews: 0, envviews: 0 };
            var totalMin = { airpol: Number.MAX_SAFE_INTEGER, globalviews: Number.MAX_SAFE_INTEGER, envviews: Number.MAX_SAFE_INTEGER };

            for (var i = 0; i < line_data.length; i++) {
                var di = line_data[i];

                // max
                if (di.airpol > totalMax.airpol) {
                    totalMax.airpol = di.airpol;
                }
                if (di.globalviews > totalMax.globalviews) {
                    totalMax.globalviews = di.globalviews;
                }
                if (di.envviews > totalMax.envviews) {
                    totalMax.envviews = di.envviews
                }

                // min
                if (di.airpol < totalMin.airpol) {
                    totalMin.airpol = di.airpol;
                }
                if (di.globalviews < totalMin.globalviews) {
                    totalMin.globalviews = di.globalviews;
                }
                if (di.envviews < totalMin.envviews) {
                    totalMin.envviews = di.envviews
                }
            }
            
            // END OF DATA
            
            //////////////////////////////////////////////////////////////////////////////
            // LAYOUT & CHARTS
            //////////////////////////////////////////////////////////////////////////////
            
            // main container
            // https://www.amcharts.com/docs/v4/concepts/svg-engine/containers/
            var container = am4core.create("chartdiv", am4core.Container);
            container.width = am4core.percent(100);
            container.height = am4core.percent(100);
            
            container.tooltip = new am4core.Tooltip();  
            container.tooltip.background.fill = am4core.color("#000000");
            container.tooltip.background.stroke = activeColor;
            container.tooltip.fontSize = "0.9em";
            container.tooltip.getFillFromObject = false;
            container.tooltip.getStrokeFromObject = false;
            
            // MAP CHART 
            // https://www.amcharts.com/docs/v4/chart-types/map/
            var mapChart = container.createChild(am4maps.MapChart);
            mapChart.height = am4core.percent(80);
            mapChart.zoomControl = new am4maps.ZoomControl();
            mapChart.zoomControl.align = "right";
            mapChart.zoomControl.marginRight = 15;
            mapChart.zoomControl.valign = "middle";
            mapChart.homeGeoPoint = { longitude: 0, latitude: -2 };
            
            // by default minus button zooms out by one step, but we modify the behavior so when user clicks on minus, the map would fully zoom-out and show world data
            mapChart.zoomControl.minusButton.events.on("hit", showWorld);
            // clicking on a "sea" will also result a full zoom-out
            mapChart.seriesContainer.background.events.on("hit", showWorld);
            mapChart.seriesContainer.background.events.on("over", resetHover);
            mapChart.seriesContainer.background.fillOpacity = 0;
            mapChart.zoomEasing = am4core.ease.sinOut;
            
            // https://www.amcharts.com/docs/v4/chart-types/map/#Map_data
            // you can use more accurate world map or map of any other country - a wide selection of maps available at: https://github.com/amcharts/amcharts4-geodata
            mapChart.geodata = am4geodata_worldLow;
            
            // Set projection
            // https://www.amcharts.com/docs/v4/chart-types/map/#Setting_projection
            // instead of Miller, you can use Mercator or many other projections available: https://www.amcharts.com/demos-v4/map-using-d3-projections/
            mapChart.projection = new am4maps.projections.Miller();
            mapChart.panBehavior = "move";
            
            // when map is globe, beackground is made visible
            mapChart.backgroundSeries.mapPolygons.template.polygon.fillOpacity = 0.05;
            mapChart.backgroundSeries.mapPolygons.template.polygon.fill = am4core.color("#ffffff");
            mapChart.backgroundSeries.hidden = true;
            
            
            // Map polygon series (defines how country areas look and behave)
            var polygonSeries = mapChart.series.push(new am4maps.MapPolygonSeries());
            polygonSeries.dataFields.id = "id";
            polygonSeries.dataFields.value = "airpolPC";
            polygonSeries.interpolationDuration = 0;
            
            polygonSeries.exclude = ["AQ"]; // Antarctica is excluded in non-globe projection
            polygonSeries.useGeodata = true;
            polygonSeries.nonScalingStroke = true;
            polygonSeries.strokeWidth = 0.5;
            // this helps to place bubbles in the visual middle of the area
            polygonSeries.calculateVisualCenter = true;
            polygonSeries.data = mapData;
            
            var polygonTemplate = polygonSeries.mapPolygons.template;
            polygonTemplate.fill = countryColor;
            polygonTemplate.fillOpacity = 1
            polygonTemplate.stroke = countryStrokeColor;
            polygonTemplate.strokeOpacity = 0.15
            polygonTemplate.setStateOnChildren = true;
            polygonTemplate.tooltipPosition = "fixed";
            
            polygonTemplate.events.on("hit", handleCountryHit);
            polygonTemplate.events.on("over", handleCountryOver);
            polygonTemplate.events.on("out", handleCountryOut);
            
            
            polygonSeries.heatRules.push({
                "target": polygonTemplate,
                "property": "fill",
                "min": countryColor,
                "max": countryColor,
                "dataField": "value"
            })
            
            
            
            // you can have pacific - centered map if you set this to -154.8
            mapChart.deltaLongitude = -10;
            
            // polygon states
            var polygonHoverState = polygonTemplate.states.create("hover");
            polygonHoverState.transitionDuration = 1400;
            polygonHoverState.properties.fill = countryHoverColor;
            
            var polygonActiveState = polygonTemplate.states.create("active")
            polygonActiveState.properties.fill = activeCountryColor;
            
            // Bubble series
            var bubbleSeries = mapChart.series.push(new am4maps.MapImageSeries());  
            bubbleSeries.data = JSON.parse(JSON.stringify(mapData));
            
            bubbleSeries.dataFields.value = "airpol";
            bubbleSeries.dataFields.id = "id";
            
            // adjust tooltip
            bubbleSeries.tooltip.animationDuration = 0;
            bubbleSeries.tooltip.showInViewport = false;
            bubbleSeries.tooltip.background.fillOpacity = 0.2;
            bubbleSeries.tooltip.getStrokeFromObject = true;
            bubbleSeries.tooltip.getFillFromObject = false;
            bubbleSeries.tooltip.background.fillOpacity = 0.2;
            bubbleSeries.tooltip.background.fill = am4core.color("#000000");
            
            var imageTemplate = bubbleSeries.mapImages.template;
            // if you want bubbles to become bigger when zoomed, set this to false
            imageTemplate.nonScaling = true;
            imageTemplate.strokeOpacity = 0;
            imageTemplate.fillOpacity = 0.55;
            imageTemplate.tooltipText = "{name}: [bold]{value}[/]";
            imageTemplate.applyOnClones = true;
            
            imageTemplate.events.on("over", handleImageOver);
            imageTemplate.events.on("out", handleImageOut);
            imageTemplate.events.on("hit", handleImageHit);

            // this is needed for the tooltip to point to the top of the circle instead of the middle
            imageTemplate.adapter.add("tooltipY", function(tooltipY, target) {
                return -target.children.getIndex(0).radius;
            })
            
            // When hovered, circles become non-opaque  
            var imageHoverState = imageTemplate.states.create("hover");
            imageHoverState.properties.fillOpacity = 1;
            
            // add circle inside the image
            var circle = imageTemplate.createChild(am4core.Circle);
            // this makes the circle to pulsate a bit when showing it
            circle.hiddenState.properties.scale = 0.0001;
            circle.hiddenState.transitionDuration = 2000;
            circle.defaultState.transitionDuration = 2000;
            circle.defaultState.transitionEasing = am4core.ease.elasticOut;
            // later we set fill color on template (when changing what type of data the map should show) and all the clones get the color because of this
            circle.applyOnClones = true;
            
            // heat rule makes the bubbles to be of a different width. Adjust min/max for smaller/bigger radius of a bubble
            bubbleSeries.heatRules.push({
                "target": circle,
                "property": "radius",
                "min": 3,
                "max": 30,
                "dataField": "value"
            })
            
            // when data items validated, hide 0 value bubbles (because min size is set)
            bubbleSeries.events.on("dataitemsvalidated", function() {
                bubbleSeries.dataItems.each((dataItem) => {
                var mapImage = dataItem.mapImage;
                var circle = mapImage.children.getIndex(0);
                if (mapImage.dataItem.value == 0) {
                    circle.hide(0);
                }
                else if (circle.isHidden || circle.isHiding) {
                    circle.show();
                }
                })
            })
            
            // this places bubbles at the visual center of a country
            imageTemplate.adapter.add("latitude", function(latitude, target) {
                var polygon = polygonSeries.getPolygonById(target.dataItem.id);
                if (polygon) {
                target.disabled = false;
                return polygon.visualLatitude;
                }
                else {
                target.disabled = true;
                }
                return latitude;
            })
            
            imageTemplate.adapter.add("longitude", function(longitude, target) {
                var polygon = polygonSeries.getPolygonById(target.dataItem.id);
                if (polygon) {
                target.disabled = false;
                return polygon.visualLongitude;
                }
                else {
                target.disabled = true;
                }
                return longitude;
            })
            
            // END OF MAP  
            
            // top title
            var title = mapChart.titles.create();
            title.fontSize = "1.5em";
            title.text = "";
            title.align = "left";
            title.horizontalCenter = "left";
            title.marginLeft = 20;
            title.paddingBottom = 10;
            title.fill = am4core.color("#ffffff");
            title.y = 20;
            
            
            // buttons & chart container
            var buttonsAndChartContainer = container.createChild(am4core.Container);
            buttonsAndChartContainer.layout = "vertical";
            buttonsAndChartContainer.height = am4core.percent(45); // make this bigger if you want more space for the chart
            buttonsAndChartContainer.width = am4core.percent(100);
            buttonsAndChartContainer.valign = "bottom";
            
            // country name and buttons container
            var nameAndButtonsContainer = buttonsAndChartContainer.createChild(am4core.Container)
            nameAndButtonsContainer.width = am4core.percent(100);
            nameAndButtonsContainer.padding(0, 10, 5, 20);
            nameAndButtonsContainer.layout = "horizontal";
            
            // name of a country and date label
            var countryName = nameAndButtonsContainer.createChild(am4core.Label);
            countryName.fontSize = "1.1em";
            countryName.fill = am4core.color("#ffffff");
            countryName.valign = "middle";
            
            // buttons container (active/airpol/globalviews/envviews)
            var buttonsContainer = nameAndButtonsContainer.createChild(am4core.Container);
            buttonsContainer.layout = "grid";
            buttonsContainer.width = am4core.percent(100);
            buttonsContainer.x = 10;
            buttonsContainer.contentAlign = "right";
            
            // Chart & slider container
            var chartAndSliderContainer = buttonsAndChartContainer.createChild(am4core.Container);
            chartAndSliderContainer.layout = "vertical";
            chartAndSliderContainer.height = am4core.percent(100);
            chartAndSliderContainer.width = am4core.percent(100);
            chartAndSliderContainer.background = new am4core.RoundedRectangle();
            chartAndSliderContainer.background.fill = am4core.color("#000000");
            chartAndSliderContainer.background.cornerRadius(30, 30, 0, 0)
            chartAndSliderContainer.background.fillOpacity = 0.25;
            chartAndSliderContainer.paddingTop = 12;
            chartAndSliderContainer.paddingBottom = 0;
            
            // Slider container
            var sliderContainer = chartAndSliderContainer.createChild(am4core.Container);
            sliderContainer.width = am4core.percent(100);
            sliderContainer.padding(0, 15, 15, 10);
            sliderContainer.layout = "horizontal";
            
            var slider = sliderContainer.createChild(am4core.Slider);
            slider.width = am4core.percent(100);
            slider.valign = "middle";
            slider.background.opacity = 0.4;
            slider.opacity = 0.7;
            slider.background.fill = am4core.color("#ffffff");
            slider.marginLeft = 20;
            slider.marginRight = 35;
            slider.height = 15;
            slider.start = 1;
            
            
            // what to do when slider is dragged
            slider.events.on("rangechanged", function(event) {
                var index = Math.round((graph_data.length - 1) * slider.start);
                updateMapData(getSlideData(index).list);
                updateTotals(index);
            })
            // stop animation if dragged
            slider.startGrip.events.on("drag", () => {
                stop();
                if (sliderAnimation) {
                    sliderAnimation.setProgress(slider.start);
                }
            });
            
            // play button
            var playButton = sliderContainer.createChild(am4core.PlayButton);
            playButton.valign = "middle";
            // play button behavior
            playButton.events.on("toggled", function(event) {
                if (event.target.isActive) {
                    play();
                } else {
                    stop();
                }
            })
            // make slider grip look like play button
            slider.startGrip.background.fill = playButton.background.fill;
            slider.startGrip.background.strokeOpacity = 0;
            slider.startGrip.icon.stroke = am4core.color("#ffffff");
            slider.startGrip.background.states.copyFrom(playButton.background.states)
            
            
            // bubble size slider
            var sizeSlider = container.createChild(am4core.Slider);
            sizeSlider.orientation = "vertical";
            sizeSlider.height = am4core.percent(12);
            sizeSlider.marginLeft = 25;
            sizeSlider.align = "left";
            sizeSlider.valign = "top";
            sizeSlider.verticalCenter = "middle";
            sizeSlider.opacity = 0.7;
            sizeSlider.background.fill = am4core.color("#ffffff");
            sizeSlider.adapter.add("y", function(y, target) {
                return container.pixelHeight * (1 - buttonsAndChartContainer.percentHeight / 100) * 0.25;
            })
            
            sizeSlider.startGrip.background.fill = activeColor;
            sizeSlider.startGrip.background.fillOpacity = 0.8;
            sizeSlider.startGrip.background.strokeOpacity = 0;
            sizeSlider.startGrip.icon.stroke = am4core.color("#ffffff");
            sizeSlider.startGrip.background.states.getKey("hover").properties.fill = activeColor;
            sizeSlider.startGrip.background.states.getKey("down").properties.fill = activeColor;
            sizeSlider.horizontalCenter = "middle";
            
            
            sizeSlider.events.on("rangechanged", function() {
                sizeSlider.startGrip.scale = 0.75 + sizeSlider.start;
                bubbleSeries.heatRules.getIndex(0).max = 30 + sizeSlider.start * 100;
                circle.clones.each(function(clone) {
                clone.radius = clone.radius;
                })
            })
            
            
            var sizeLabel = container.createChild(am4core.Label);
            sizeLabel.text = "max bubble size *";
            sizeLabel.fill = am4core.color("#ffffff");
            sizeLabel.rotation = 90;
            sizeLabel.fontSize = "10px";
            sizeLabel.fillOpacity = 0.5;
            sizeLabel.horizontalCenter = "middle";
            sizeLabel.align = "left"
            sizeLabel.paddingBottom = 40;
            sizeLabel.tooltip.setBounds({ x: 0, y: 0, width: 200000, height: 200000 })
            sizeLabel.tooltip.label.wrap = true;
            sizeLabel.tooltip.label.maxWidth = 300;
            sizeLabel.tooltipText = "Some countries have values so big that bubbles for countries with smaller values often look the same even if there is a significant difference between them. This slider can be used to increase maximum size of a bubble so that when you zoom in to a region with relatively small values you could compare them anyway."
            sizeLabel.fill = am4core.color("#ffffff");
            
            sizeLabel.adapter.add("y", function(y, target) {
                return container.pixelHeight * (1 - buttonsAndChartContainer.percentHeight / 100) * 0.25;
            })
            
            // filter slider
            
            // bubble size slider
            var filterSlider = container.createChild(am4core.Slider);
            filterSlider.orientation = "vertical";
            filterSlider.height = am4core.percent(28);
            filterSlider.marginLeft = 25;
            filterSlider.align = "left";
            filterSlider.valign = "top";
            filterSlider.verticalCenter = "middle";
            filterSlider.opacity = 0.7;
            filterSlider.background.fill = am4core.color("#ffffff");
            filterSlider.adapter.add("y", function(y, target) {
                return container.pixelHeight * (1 - buttonsAndChartContainer.percentHeight / 100) * 0.7;
            })
            
            filterSlider.startGrip.background.fill = activeColor;
            filterSlider.startGrip.background.fillOpacity = 0.8;
            filterSlider.startGrip.background.strokeOpacity = 0;
            filterSlider.startGrip.icon.stroke = am4core.color("#ffffff");
            filterSlider.startGrip.background.states.getKey("hover").properties.fill = activeColor;
            filterSlider.startGrip.background.states.getKey("down").properties.fill = activeColor;
            filterSlider.horizontalCenter = "middle";
            filterSlider.start = 1;
            
            
            filterSlider.events.on("rangechanged", function() {
                var maxValue = max[currentType] * filterSlider.start + 1;
                if (!isNaN(maxValue) && bubbleSeries.inited) {
                    bubbleSeries.heatRules.getIndex(0).maxValue = maxValue;
                    circle.clones.each(function(clone) {
                        if (clone.dataItem.value > maxValue) {
                            clone.dataItem.hide();
                        }
                        else {
                            clone.dataItem.show();
                        }
                        clone.radius = clone.radius;
                    })
                }
            })
            
            
            var filterLabel = container.createChild(am4core.Label);
            filterLabel.text = "filter max values *";
            filterLabel.rotation = 90;
            filterLabel.fontSize = "10px";
            filterLabel.fill = am4core.color("#ffffff");
            filterLabel.fontSize = "0.8em";
            filterLabel.fillOpacity = 0.5;
            filterLabel.horizontalCenter = "middle";
            filterLabel.align = "left"
            filterLabel.paddingBottom = 40;
            filterLabel.tooltip.label.wrap = true;
            filterLabel.tooltip.label.maxWidth = 300;
            filterLabel.tooltipText = "This filter allows to remove countries with many cases from the map so that it would be possible to compare countries with smaller number of cases."
            filterLabel.fill = am4core.color("#ffffff");
            
            filterLabel.adapter.add("y", function(y, target) {
                return container.pixelHeight * (1 - buttonsAndChartContainer.percentHeight / 100) * 0.7;
            })
            
            
            
            // play behavior
            function play() {
                if (!sliderAnimation) {
                    sliderAnimation = slider.animate({ property: "start", to: 1, from: 0 }, 50000, am4core.ease.linear).pause();
                    sliderAnimation.events.on("animationended", () => {
                        playButton.isActive = false;
                    })
                }
            
                if (slider.start >= 1) {
                slider.start = 0;
                sliderAnimation.start();
                }
                sliderAnimation.resume();
                playButton.isActive = true;
            }
            
            // stop behavior
            function stop() {
                if (sliderAnimation) {
                    sliderAnimation.pause();
                }
                playButton.isActive = false;
            }
            
            // BOTTOM CHART
            // https://www.amcharts.com/docs/v4/chart-types/xy-chart/
            var lineChart = chartAndSliderContainer.createChild(am4charts.XYChart);
            lineChart.fontSize = "0.8em";
            lineChart.paddingRight = 30;
            lineChart.paddingLeft = 30;
            lineChart.maskBullets = false;
            lineChart.zoomOutButton.disabled = true;
            lineChart.paddingBottom = 5;
            lineChart.paddingTop = 3;
            
            // make a copy of data as we will be modifying it
            lineChart.data = JSON.parse(JSON.stringify(line_data));
            
            // date axis
            // https://www.amcharts.com/docs/v4/concepts/axes/date-axis/
            var dateAxis = lineChart.xAxes.push(new am4charts.DateAxis());
            dateAxis.renderer.minGridDistance = 50;
            dateAxis.renderer.grid.template.stroke = am4core.color("#000000");
            dateAxis.renderer.grid.template.strokeOpacity = 0.25;
            dateAxis.max = lastDate.getTime() + am4core.time.getDuration("day", 5);
            dateAxis.tooltip.label.fontSize = "0.8em";
            dateAxis.tooltip.background.fill = activeColor;
            dateAxis.tooltip.background.stroke = activeColor;
            dateAxis.renderer.labels.template.fill = am4core.color("#ffffff");

            
            // value axis
            // https://www.amcharts.com/docs/v4/concepts/axes/value-axis/
            var valueAxis = lineChart.yAxes.push(new am4charts.ValueAxis());
            valueAxis.renderer.opposite = true;
            valueAxis.interpolationDuration = 3000;
            valueAxis.renderer.grid.template.stroke = am4core.color("#000000");
            valueAxis.renderer.grid.template.strokeOpacity = 0.25;
            valueAxis.renderer.minGridDistance = 30;
            valueAxis.renderer.maxLabelPosition = 0.98;
            valueAxis.renderer.baseGrid.disabled = true;
            valueAxis.tooltip.disabled = true;
            //valueAxis.extraMax = 0;

            valueAxis.maxPrecision = 0;
            valueAxis.renderer.inside = true;
            valueAxis.renderer.labels.template.verticalCenter = "bottom";
            valueAxis.renderer.labels.template.fill = am4core.color("#ffffff");
            valueAxis.renderer.labels.template.padding(2, 2, 2, 2);

            // cursor
            // https://www.amcharts.com/docs/v4/concepts/chart-cursor/
            lineChart.cursor = new am4charts.XYCursor();
            lineChart.cursor.maxTooltipDistance = 0;
            lineChart.cursor.behavior = "none"; // set zoomX for a zooming possibility
            lineChart.cursor.lineY.disabled = true;
            lineChart.cursor.lineX.stroke = activeColor;
            lineChart.cursor.xAxis = dateAxis;
            // this prevents cursor to move to the clicked location while map is dragged
            am4core.getInteraction().body.events.off("down", lineChart.cursor.handleCursorDown, lineChart.cursor)
            am4core.getInteraction().body.events.off("up", lineChart.cursor.handleCursorUp, lineChart.cursor)
            
            // legend
            // https://www.amcharts.com/docs/v4/concepts/legend/  
            lineChart.legend = new am4charts.Legend();
            lineChart.legend.parent = lineChart.plotContainer;
            lineChart.legend.labels.template.fill = am4core.color("#ffffff");
            lineChart.legend.markers.template.height = 8;
            lineChart.legend.contentAlign = "left";
            lineChart.legend.fontSize = "10px";
            lineChart.legend.itemContainers.template.valign = "middle";
            var legendDown = false;
            lineChart.legend.itemContainers.template.events.on("down", function() {
                legendDown = true;
            })
            lineChart.legend.itemContainers.template.events.on("up", function() {
                setTimeout(function() {
                legendDown = false;
                }, 100)
            })
            lineChart.legend.itemContainers.template.events.on("hit", function(ev) {
                if (currentPolygon == undefined) {
                    var min = Number.MAX_SAFE_INTEGER;
                    var max = 0;
                    var name = getDataName(ev.target.dataItem.dataContext.name);

                    if (!series[name].visible) {
                        if (min > totalMin[name]) {
                            min = totalMin[name];
                        }
                        
                        if (max < totalMax[name]) {
                            max = totalMax[name];
                        }
                    }

                    for (key in series) {
                        if (key != name) {
                            if (series[key].visible) {
                                if (min > totalMin[key]) {
                                    min = totalMin[key];
                                }
                                
                                if (max < totalMax[key]) {
                                    max = totalMax[key];
                                }
                            }
                        }
                    }
                    

                    valueAxis.min = min;
                    valueAxis.max = max;
                }
            })
            
            
            // create series
            var airpolSeries = addSeries("airpol", airpolColor);
            // active series is visible initially
            airpolSeries.tooltip.disabled = true;
            airpolSeries.hidden = false;
            
            var globalviewsSeries = addSeries("globalviews", globalviewsColor);
            var envviewsSeries = addSeries("envviews", envviewsColor);
            
            var series = { airpol: airpolSeries, globalviews: globalviewsSeries, envviews: envviewsSeries };
            // add series
            function addSeries(name, color) {
                var series = lineChart.series.push(new am4charts.LineSeries())
                series.dataFields.valueY = name;
                series.dataFields.dateX = "date";
                series.name = createName(name);
                series.strokeOpacity = 0.6;
                series.stroke = color;
                series.fill = color;
                series.maskBullets = false;
                series.minBulletDistance = 10;
                //series.minDistance = 100
                series.hidden = true;
                series.hideTooltipWhileZooming = true;
            
            
                // series bullet
                var bullet = series.bullets.push(new am4charts.CircleBullet());
            
                // only needed to pass it to circle
                var bulletHoverState = bullet.states.create("hover");
                bullet.setStateOnChildren = true;
            
                bullet.circle.fillOpacity = 1;
                bullet.circle.fill = backgroundColor;
                bullet.circle.radius = 2;
            
                var circleHoverState = bullet.circle.states.create("hover");
                circleHoverState.properties.fillOpacity = 1;
                circleHoverState.properties.fill = color;
                circleHoverState.properties.scale = 1.4;
            
                // tooltip setup
                series.tooltip.pointerOrientation = "down";
                series.tooltip.getStrokeFromObject = true;
                series.tooltip.getFillFromObject = false;
                series.tooltip.background.fillOpacity = 0.2;
                series.tooltip.background.fill = am4core.color("#000000");
                series.tooltip.dy = -4;
                series.tooltip.fontSize = "0.8em";
                series.tooltipText = "Total {name}: {valueY}";
            
                return series;
            }
            
            
            var series = {airpol: airpolSeries, globalviews: globalviewsSeries, envviews: envviewsSeries };
            
            lineChart.plotContainer.events.on("up", function() {
                if (!legendDown) {
                slider.start = lineChart.cursor.xPosition * ((dateAxis.max - dateAxis.min) / (lastDate.getTime() - dateAxis.min));
                }
            })
            
            
            // BUTTONS
            // create buttons
            var airpolButton = addButton("airpol", airpolColor);
            var globalviewsButton = addButton("globalviews", globalviewsColor);
            var envviewsButton = addButton("envviews", envviewsColor);
            
            var buttons = { airpol: airpolButton, globalviews: globalviewsButton, envviews: envviewsButton };
            
            // add button
            function addButton(name, color) {
                var button = buttonsContainer.createChild(am4core.Button)
                button.label.valign = "middle"
                button.label.fill = am4core.color("#ffffff");
                button.label.fontSize = "11px";
                button.background.cornerRadius(30, 30, 30, 30);
                button.background.strokeOpacity = 0.3
                button.background.fillOpacity = 0;
                button.background.stroke = buttonStrokeColor;
                button.background.padding(2, 3, 2, 3);
                button.states.create("active");
                button.setStateOnChildren = true;
            
                var activeHoverState = button.background.states.create("hoverActive");
                activeHoverState.properties.fillOpacity = 0;
            
                var circle = new am4core.Circle();
                circle.radius = 8;
                circle.fillOpacity = 0.3;
                circle.fill = buttonStrokeColor;
                circle.strokeOpacity = 0;
                circle.valign = "middle";
                circle.marginRight = 5;
                button.icon = circle;
            
                // save name to dummy data for later use
                button.dummyData = name;
            
                var circleActiveState = circle.states.create("active");
                circleActiveState.properties.fill = color;
                circleActiveState.properties.fillOpacity = 0.5;
            
                button.events.on("hit", handleButtonClick);
            
                return button;
            }
            
            // handle button clikc
            function handleButtonClick(event) {
                // we saved name to dummy data
                changeDataType(event.target.dummyData);
            }
            
            // change data type (active/airpol/globalviews/envviews)
            function changeDataType(name) {
                currentType = name;
                currentTypeName = name;
            
                bubbleSeries.mapImages.template.tooltipText = "[bold]{name}: {value}[/] [font-size:10px]\n" + createName(currentTypeName);
            
                // make button active
                var activeButton = buttons[name];
                activeButton.isActive = true;
                // make other buttons inactive
                for (var key in buttons) {
                    if (buttons[key] != activeButton) {
                        buttons[key].isActive = false;
                    }
                }
                // tell series new field name
                bubbleSeries.dataFields.value = name;
                polygonSeries.dataFields.value = name + "PC";
            
                bubbleSeries.dataItems.each(function(dataItem) {
                    dataItem.setValue("value", dataItem.dataContext[currentType]);
                })
            
                polygonSeries.dataItems.each(function(dataItem) {
                    dataItem.setValue("value", dataItem.dataContext[currentType + "PC"]);
                    dataItem.mapPolygon.defaultState.properties.fill = undefined;
                })
            
            
                // change color of bubbles
                // setting colors on mapImage for tooltip colors
                bubbleSeries.mapImages.template.fill = colors[name];
                bubbleSeries.mapImages.template.stroke = colors[name];
                // first child is circle
                bubbleSeries.mapImages.template.children.getIndex(0).fill = colors[name];
            
                dateAxis.tooltip.background.fill = colors[name];
                dateAxis.tooltip.background.stroke = colors[name];
                lineChart.cursor.lineX.stroke = colors[name];
            
                // show series
                var activeSeries = series[name];
                activeSeries.show();

                valueAxis.min = totalMin[name];
                valueAxis.max = totalMax[name];
                

                // hide other series
                for (var key in series) {
                    if (series[key] != activeSeries) {
                        series[key].hide();
                    }
                }
                
            
                // update heat rule's maxValue
                bubbleSeries.heatRules.getIndex(0).maxValue = max[currentType];
                polygonSeries.heatRules.getIndex(0).maxValue = maxPC[currentType];
                if (perCapita) {
                    polygonSeries.heatRules.getIndex(0).max = colors[name];
                    updateCountryTooltip();
                }
            }
        
            
            function updateSeriesTooltip() {
            
                var position = dateAxis.dateToPosition(currentDate);
                position = dateAxis.toGlobalPosition(position);
                var x = dateAxis.positionToCoordinate(position);
            
                lineChart.cursor.triggerMove({ x: x, y: 0 }, "soft", true);
                lineChart.series.each(function(series) {
                if (!series.isHidden) {
                    series.tooltip.disabled = false;
                    series.showTooltipAtDataItem(series.tooltipDataItem);
                }
                })
            }
            
            // what happens when a country is rolled-over
            function rollOverCountry(mapPolygon) {
            
                resetHover();
                if (mapPolygon) {
                    mapPolygon.isHover = true;
                
                    // make bubble hovered too
                    var image = bubbleSeries.getImageById(mapPolygon.dataItem.id);
                    if (image) {
                        image.dataItem.dataContext.name = mapPolygon.dataItem.dataContext.name;
                        image.isHover = true;
                    }
                }
            }
            // what happens when a country is rolled-out
            function rollOutCountry(mapPolygon) {
                var image = bubbleSeries.getImageById(mapPolygon.dataItem.id)
            
                resetHover();
                if (image) {
                    image.isHover = false;
                }
            }

            function setCountryData(countryIndex) {
                // instead of setting whole data array, we modify current raw data so that a nice animation would happen
                for (var i = 0; i < lineChart.data.length; i++) {
                    var di = graph_data[i].list;

                    var countryData = di[countryIndex];
                    var dataContext = lineChart.data[i];
                    if (countryData) {
                        dataContext.airpol = countryData.airpol;
                        dataContext.envviews = countryData.envviews;
                        dataContext.globalviews = countryData.globalviews;
                        valueAxis.min = undefined;
                        valueAxis.max = undefined;
                    }
                }

                lineChart.invalidateRawData();
                updateTotals(currentIndex);
                setTimeout(updateSeriesTooltip, 1000);
            }
            
            // rotate and zoom
            function rotateAndZoom(mapPolygon) {
                polygonSeries.hideTooltip();
                var animation = mapChart.animate([{ property: "deltaLongitude", to: -mapPolygon.visualLongitude }, { property: "deltaLatitude", to: -mapPolygon.visualLatitude }], 1000)
                animation.events.on("animationended", function() {
                    mapChart.zoomToMapObject(mapPolygon, getZoomLevel(mapPolygon));
                })
            }
            
            // calculate zoom level (default is too close)
            function getZoomLevel(mapPolygon) {
                var w = mapPolygon.polygon.bbox.width;
                var h = mapPolygon.polygon.bbox.width;
                // change 2 to smaller walue for a more close zoom
                return Math.min(mapChart.seriesWidth / (w * 2), mapChart.seriesHeight / (h * 2))
            }
            
            // show world data
            function showWorld() {
                currentCountry = "World";
                currentPolygon = undefined;
                resetHover();
            
                if (countryDataTimeout) {
                    clearTimeout(countryDataTimeout);
                }
            
                // make all inactive
                polygonSeries.mapPolygons.each(function(polygon) {
                    polygon.isActive = false;
                })
            
                updateCountryName();
            
                // update line chart data (again, modifying instead of setting new data for a nice animation)
                for (var i = 0; i < lineChart.data.length; i++) {
                    var di = line_data[i];
                    var dataContext = lineChart.data[i];
                
                    dataContext.globalviews = di.globalviews;
                    dataContext.airpol = di.airpol;
                    dataContext.envviews = di.envviews;
                }

                var min = Number.MAX_SAFE_INTEGER;
                var max = 0;

                for (key in series) {
                    if (series[key].visible) {
                        if (min > totalMin[key]) {
                            min = totalMin[key];
                        }
                        
                        if (max < totalMax[key]) {
                            max = totalMax[key];
                        }
                    }
                }
                

                valueAxis.min = min;
                valueAxis.max = max;
            
                lineChart.invalidateRawData();
            
                updateTotals(currentIndex);
                mapChart.goHome();
            }
            
            // updates country name and date
            function updateCountryName() {
                countryName.text = currentCountry + ", " + mapChart.dateFormatter.format(currentDate, "MMM dd, yyyy");
            }
            
            // update total values in buttons
            function updateTotals(index) {
                if (!isNaN(index)) {
                    var di = line_data[index];
                    var date = new Date(di.date);
                    currentDate = date;
                
                    updateCountryName();
                
                    var position = dateAxis.dateToPosition(date);
                    position = dateAxis.toGlobalPosition(position);
                    var x = dateAxis.positionToCoordinate(position);
                
                    if (lineChart.cursor) {
                        lineChart.cursor.triggerMove({ x: x, y: 0 }, "soft", true);
                    }
                    for (var key in buttons) {
                        var count = Number(lineChart.data[index][key])
                        if (!isNaN(count)) {
                            buttons[key].label.text = createName(key) + ": " + numberFormatter.format(count, '#,###.##');
                        }
                    }
                    currentIndex = index;
                }
            }
            
            // update map data
            function updateMapData(data) {
                //modifying instead of setting new data for a nice animation
                bubbleSeries.dataItems.each(function(dataItem) {
                    dataItem.dataContext.airpol = 0;
                    dataItem.dataContext.envviews = 0;
                    dataItem.dataContext.globalviews = 0;
                })
            
                maxPC = { airpol: 0, envviews: 0, globalviews: 0 };
            
                for (var i = 0; i < data.length; i++) {
                    var di = data[i];
                    var image = bubbleSeries.getImageById(di.id);
                    var polygon = polygonSeries.getPolygonById(di.id);
                
                    if (image) {
                        var population = Number(populations[image.dataItem.dataContext.id]);
                
                        image.dataItem.dataContext.airpol = di.airpol;
                        image.dataItem.dataContext.envviews = di.envviews;
                        image.dataItem.dataContext.globalviews = di.globalviews;
                    }
                
                    if (polygon) {
                        polygon.dataItem.dataContext.airpolPC = di.airpol / population * 1000000;
                        polygon.dataItem.dataContext.envviewsPC = di.envviews / population * 1000000;
                        polygon.dataItem.dataContext.globalviewsPC = di.globalviews / population * 1000000;
                
                        if (population > 100000) {
                            if (polygon.dataItem.dataContext.airpolPC > maxPC.airpol) {
                                maxPC.airpol = polygon.dataItem.dataContext.airpolPC;
                            }
                            if (polygon.dataItem.dataContext.envviewsPC > maxPC.envviews) {
                                maxPC.envviews = polygon.dataItem.dataContext.envviewsPC;
                            }
                            if (polygon.dataItem.dataContext.globalviewsPC > maxPC.globalviews) {
                                maxPC.globalviews = polygon.dataItem.dataContext.globalviewsPC;
                            }
                        }
                    }
                
                    bubbleSeries.heatRules.getIndex(0).maxValue = max[currentType];
                    polygonSeries.heatRules.getIndex(0).maxValue = maxPC[currentType];
                
                    bubbleSeries.invalidateRawData();
                    polygonSeries.invalidateRawData();
                }
            }

            // select a country
            function selectCountry(mapPolygon) {
                resetHover();
                polygonSeries.hideTooltip();

                // if the same country is clicked show world
                if (currentPolygon == mapPolygon) {
                    currentPolygon.isActive = false;
                    currentPolygon = undefined;
                    showWorld();
                    return;
                }
                // save current polygon
                currentPolygon = mapPolygon;
                var countryIndex = countryIndexMap[mapPolygon.dataItem.id];
                currentCountry = mapPolygon.dataItem.dataContext.name;

                // make others inactive
                polygonSeries.mapPolygons.each(function(polygon) {
                    polygon.isActive = false;
                })

                // clear timeout if there is one
                if (countryDataTimeout) {
                    clearTimeout(countryDataTimeout);
                }
                // we delay change of data for better performance (so that data is not changed whil zooming)
                countryDataTimeout = setTimeout(function() {
                    setCountryData(countryIndex);
                }, 1000); // you can adjust number, 1000 is one second

                updateTotals(currentIndex);
                updateCountryName();

                mapPolygon.isActive = true;
                // meaning it's globe
                mapChart.zoomToMapObject(mapPolygon, getZoomLevel(mapPolygon));
            }
            
            // capitalize first letter
            function createName(string) {
                if (string == "airpol") {
                    return "Air Pollution";
                } else if (string == "envviews") {
                    return "Environment Topic Views";
                }
                
                return "Wikipedia Views";
            }
            
            function getDataName(string) {
                if (string == "Air Pollution") {
                    return "airpol";
                } else if (string == "Environment Topic Views") {
                    return "envviews";
                }

                return "globalviews";
            }
            
            
            function handleImageOver(event) {
                rollOverCountry(polygonSeries.getPolygonById(event.target.dataItem.id));
            }
            
            function handleImageOut(event) {
                rollOutCountry(polygonSeries.getPolygonById(event.target.dataItem.id));
            }
            
            function handleCountryOver(event) {
                rollOverCountry(event.target);
            }
            
            function handleCountryOut(event) {
                rollOutCountry(event.target);
            }

            function handleImageHit(event) {
                selectCountry(polygonSeries.getPolygonById(event.target.dataItem.id));
            }

            function handleCountryHit(event) {
                selectCountry(event.target);
            }

            
            function resetHover() {
                polygonSeries.mapPolygons.each(function(polygon) {
                polygon.isHover = false;
                })
            
                bubbleSeries.mapImages.each(function(image) {
                image.isHover = false;
                })
            }
            
            container.events.on("layoutvalidated", function() {
                dateAxis.tooltip.hide();
                lineChart.cursor.hide();
                updateTotals(currentIndex);
            });
            
            // set initial data and names
            updateCountryName();
            changeDataType("globalviews");
            //populateCountries(slideData.list);
            
            setTimeout(updateSeriesTooltip, 3000);
            
            function updateCountryTooltip() {
                polygonSeries.mapPolygons.template.tooltipText = "[bold]{name}: {value.formatNumber('#.')}[/]\n[font-size:10px]" + currentTypeName + " per million"
            }
            
            /**
             * Country/state list on the right
             */
            /*
            function populateCountries(list) {
                var table = $("#areas tbody");
                table.find(".area").remove();
                for (var i = 0; i < list.length; i++) {
                var area = list[i];
                var tr = $("<tr>").addClass("area").data("areaid", area.id).appendTo(table).on("click", function() {
                    selectCountry(polygonSeries.getPolygonById($(this).data("areaid")));
                }).hover(function() {
                    rollOverCountry(polygonSeries.getPolygonById($(this).data("areaid")));
                });
                $("<td>").appendTo(tr).data("areaid", area.id).html(area.name);
                $("<td>").addClass("value").appendTo(tr).html(area.airpol);
                $("<td>").addClass("value").appendTo(tr).html(area.envviews);
                $("<td>").addClass("value").appendTo(tr).html(area.globalviews);
            
                }
                $("#areas").DataTable({
                "paging": false,
                "select": true
                }).column("1")
                .order("desc")
                .draw();;
            }
            */
            
            //function idToName(id) {
                //return am4geodata_data_countries2[id] ? am4geodata_data_countries2[id].country : id == "XX" ? "Others" : id;
            //}
            
            function removeAntarctica(mapData) {
                for (var i = mapData.length - 1; i >= 0; i--) {
                if (mapData[i].id == "AQ") {
                    mapData.splice(i, 1);
                }
                }
            }
            
            var populations = {
                "JP": "127288000",
                "IT": "60340328",
                "DK": "5484000",
                "TR": "77804122",
                "NO": "5009150",
                "US": "310232863",
                "RS": "7344847",
                "SE": "9828655",
                "NL": "16645000",
                "DE": "81802257",
                "FR": "64768389",
                "ES": "46505963",
                "KR": "48422644",
                "FI": "5244000"
            }

            });
            
            }); // end am4core.ready()
        })
    })
    </script>

    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>

    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/ada-2022-project-wetried/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/ada-2022-project-wetried/assets/js/index.js"></script>

</body>
</html>
